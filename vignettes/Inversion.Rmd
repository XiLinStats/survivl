---
title: "Inversion"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Inversion}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

As usual, we begin by loading the library.

```{r setup}
library(survivl)
```

## Inversion simulation

Simulation can now be performed using inversion of CDFs directly, which removes
a computational bottleneck that existed with the rejection sampling approach. The
model specification is slightly different, however.  Taking the example from 
the `Causal Survival Analysis` vignette, we specify:

```{r MSM_forms}
formulas <- list(list(),
                 Z ~ X_l1,
                 X ~ Z_l0,
                 Y ~ X_l0,
                 cop = list(Y = list(Z_l0 ~ 1)))  # this component changed
pars <- list(Z = list(beta=c(1,0.5), phi=1),
             X = list(beta=c(-0.25,0.5)),
             Y = list(beta=c(1.1,-0.5), lambda0=0.01),
             cop = list(Y=list(Z_l0=list(beta=1))))  # this component changed
family <- list(integer(0), 1, 5, 3, 1)  # unchanged
```

Then we can, as before, call our code:
Now we call the function `cox_samp`, which obtains samples from this model.
```{r MSM_datasamp}
set.seed(123)
dati <- cox_samp(1e4, T=5,
                formulas = formulas, 
                family = family, 
                pars = pars,
                link = list(character(0), "identity", "logit", "inverse"))
datl <- surv_to_long(dati)
```

## Fitting

```{r survey_load, message=FALSE}
library(survey)
library(dplyr)
```
Now, we fit a GLM to obtain the weighting to use with $X$.
```{r weights}
modX <- glm(X ~ Z, family=binomial, data=datl)
summary(modX)
pred <- predict(modX, type="response")
datl <- datl %>% dplyr::mutate(datl, wts = X/pred + (1-X)/(1-pred))
```

At this point we can fit the model to obtain the coefficients for the effect
of $X$ on $Y$.
```{r MSM_fit}
mod <- svyglm(I(1-Y) ~ X, 
              family=binomial(link=log), 
              design = svydesign(ids=datl$id,
                                 weights=datl$wts,
                                 data=datl))
summary(mod)
```

## A NaÃ¯ve Approach

If we ignore the fact that the covariates are time-varying, we will obtain a biased estimate of the coefficient of $X$ on $Y$.

```{r naive_fit}
mod_naive <- svyglm(Y ~ X, 
              family=binomial(link=log), 
              design = svydesign(ids=datl$id,
                                 data=datl))
summary(mod_naive)
```
